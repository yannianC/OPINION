# 深度差相关逻辑说明

## 一、设置字段

在 `hedgeMode` 中新增了以下设置字段（默认值）：

```javascript
delayTimeGt15: '300-600',        // 深度差15以上挂单后延时检测时间（秒）
delayTime2To15: '30-60',          // 深度差2-15挂单后延时检测时间（秒）
delayTime02To2: '0.5-0.5',        // 深度差0.2-2挂单后延时检测时间（秒）
maxEatValue01: 20,                 // 深度差0.1时，最大多吃价值（U）
maxPriceVolatility: 10            // 先挂方价格最大波动（买卖深度差的百分比）
```

## 二、核心流程

### 1. 订单薄数据获取和预处理

**位置**: `parseOrderbookData` 函数

**流程**:
1. 获取YES和NO的订单薄数据
2. **保存原始订单薄数据**（不剔除挂单）- 用于后续价格计算
3. 获取挂单数据（`calLimitOrder` API）
4. 从订单薄中**剔除我们的挂单**（用于判断先挂方和深度差）
5. 确定先挂方（根据开仓/平仓模式）
6. 计算深度差 = `Math.abs(卖一价 - 买一价)`（使用剔除挂单后的数据）

### 2. 深度差计算和价格计算

**位置**: `parseOrderbookData` 函数（8122-8273行）

**关键变量**:
- `depthDiff`: 深度差（卖一减去买一的绝对值）
- `price1`: 先挂方的买一价（剔除挂单后）
- `price2`: 先挂方的卖一价（剔除挂单后）
- `rawBid1`: 原始数据的买一价（不剔除挂单）
- `rawAsk1`: 原始数据的卖一价（不剔除挂单）
- `rawBid1Depth`: 原始数据的买一深度
- `rawAsk1Depth`: 原始数据的卖一深度

**辅助函数**:
```javascript
// 从范围字符串中获取随机值（秒）
getRandomFromRange(rangeStr) {
  const [min, max] = rangeStr.split('-').map(v => parseFloat(v.trim()))
  return Math.random() * (max - min) + min
}

// 计算价格调整值（深度差的1%到maxPriceVolatility%之间，最小0.1）
calculatePriceAdjustment(diff) {
  const minAdjust = Math.max(0.1, diff * 0.01)
  const maxAdjust = diff * maxPriceVolatility
  return Math.random() * (maxAdjust - minAdjust) + minAdjust
}
```

### 3. 根据深度差范围计算价格和tp2

#### 情况1: 深度差 > 15

**判断条件**: 
- 先判断 `(买一价+卖一价)/2` 是否大于"先挂方价格区间"的最小值
- 如果不符合，抛出错误："深度差>15时，平均价格不大于价格区间最小值"

**价格计算**:
- **平仓**: `finalPrice = 原始数据的卖一价 - 深度差的1%-10%随机值`
- **开仓**: `finalPrice = 原始数据的买一价 + 深度差的1%-10%随机值`

**tp2计算**: 
- 从 `delayTimeGt15` 设置中取随机值（默认300-600秒）

---

#### 情况2: 深度差 2-15

**价格计算**:
- **平仓**: `finalPrice = 原始数据的卖一价 - 深度差的1%-10%随机值`
- **开仓**: `finalPrice = 原始数据的买一价 + 深度差的1%-10%随机值`

**tp2计算**: 
- 从 `delayTime2To15` 设置中取随机值（默认30-60秒）

---

#### 情况3: 深度差 0.2-2

**价格计算**:
- **平仓**: `finalPrice = 原始数据的卖一价 - 深度差的1%-10%随机值`
- **开仓**: `finalPrice = 原始数据的买一价 + 深度差的1%-10%随机值`

**tp2计算**: 
- 从 `delayTime02To2` 设置中取随机值（默认0.5-0.5秒）

---

#### 情况4: 深度差 = 0.1（允许0.09-0.11的误差）

**平仓模式**:
1. 计算卖一价值 = `原始数据的卖一价 × 原始数据的卖一深度`
2. 如果 `卖一价值 < 最大允许深度(maxDepth)`:
   - ✅ 符合要求，使用 `finalPrice = 原始数据的卖一价`
3. 如果 `卖一价值 >= 最大允许深度`:
   - ❌ 不符合要求，抛出错误

**开仓模式**:
1. 计算买一价值 = `原始数据的买一价 × 原始数据的买一深度`
2. 如果 `买一价值 < 最大允许深度(maxDepth)`:
   - ✅ 符合要求，使用 `finalPrice = 原始数据的买一价`
   - `extraShare = 0`
3. 如果 `买一价值 >= 最大允许深度`:
   - 检查卖一价值 = `原始数据的卖一价 × 原始数据的卖一深度`
   - 如果 `卖一价值 < 最大多吃价值(maxEatValue01)`:
     - ✅ 符合要求，使用 `finalPrice = 原始数据的卖一价`
     - `extraShare = 原始数据的卖一深度`（需要增加的数量）
   - 如果 `卖一价值 >= 最大多吃价值`:
     - ❌ 不符合要求，抛出错误

**tp2计算**: 
- 从 `delayTime02To2` 设置中取随机值（默认0.5-0.5秒）

---

#### 情况5: 其他深度差范围

**价格计算**: 
- `finalPrice = (买一价 + 卖一价) / 2`（使用剔除挂单后的数据）

**tp2**: 
- `tp2 = null`

---

### 4. 返回数据

`parseOrderbookData` 函数返回的对象包含：

```javascript
{
  firstSide,           // 先挂方 (YES/NO)
  price1,              // 先挂方的买一价（剔除挂单后）
  price2,              // 先挂方的卖一价（剔除挂单后）
  depth1,              // 先挂方的买一深度
  depth2,              // 先挂方的卖一深度
  diff: depthDiff,     // 先挂方买卖价差（深度差）
  minPrice,            // 最小价格
  maxPrice,            // 最大价格
  topNBidsDepth,       // 买1-N深度累计
  topNAsksDepth,       // 卖1-N深度累计
  finalPrice,          // 计算出的最终价格 ⭐
  tp2,                 // 延时检测时间（秒）⭐
  extraShare,          // 深度差0.1时，开仓模式下需要额外增加的数量 ⭐
  rawAsk1Depth         // 原始数据的卖一深度
}
```

## 三、执行对冲

### 1. executeHedgeFromOrderbook 函数

**位置**: 8429行

**流程**:
1. 使用 `priceInfo.finalPrice` 作为订单价格（如果存在）
2. 如果 `finalPrice` 不存在，使用旧逻辑（兼容处理）
3. 调用API获取对冲双方数据
4. 将 `tp2` 和 `extraShare` 传递给任务执行函数

```javascript
await executeHedgeTask(config, {
  ...hedgeData,
  currentPrice: orderPrice,      // 使用计算出的finalPrice
  firstSide: priceInfo.firstSide,
  tp2: priceInfo.tp2,            // 传递tp2值
  extraShare: priceInfo.extraShare || 0  // 传递需要额外增加的数量
})
```

### 2. executeHedgeTask 函数

**位置**: 10400行

**流程**:
1. **处理深度差0.1的特殊情况**:
   ```javascript
   // 如果是开仓且使用了卖一价，需要增加先挂方的数量
   if (hedgeData.extraShare && hedgeData.extraShare > 0 && !hedgeMode.isClose) {
     calculatedShare += hedgeData.extraShare
   }
   ```

2. **提交任务时添加tp2字段**:
   ```javascript
   const taskData = {
     // ... 其他字段
     price: hedgeData.currentPrice,
     tp3: isFastMode.value ? "1" : "0"
   }
   
   // 如果tp2有值，添加到任务数据中
   if (hedgeData.tp2 !== null && hedgeData.tp2 !== undefined) {
     taskData.tp2 = Math.round(hedgeData.tp2)  // tp2转换为整数（秒）
   }
   ```

### 3. executeHedgeTaskV2 函数（模式2和模式3）

**位置**: 10968行

**流程**:
- 同样在提交任务时添加 `tp2` 字段
- 先挂方和后挂方的任务都会添加 `tp2`

## 四、关键点总结

1. **深度差计算**: 使用剔除挂单后的数据计算深度差
2. **价格计算**: 使用原始数据（不剔除挂单）计算最终价格
3. **价格调整**: 深度差1%-10%（由maxPriceVolatility控制）之间随机，最小0.1
4. **tp2字段**: 根据深度差范围从对应设置中取随机值，提交任务时添加到taskData
5. **深度差0.1特殊处理**: 
   - 平仓：直接检查卖一价值
   - 开仓：先检查买一价值，不符合则检查卖一价值，如果使用卖一价需要增加数量

## 五、数据流向图

```
获取订单薄数据
    ↓
保存原始数据（不剔除挂单）
    ↓
剔除我们的挂单
    ↓
计算深度差（剔除挂单后的数据）
    ↓
根据深度差范围计算 finalPrice 和 tp2（使用原始数据）
    ↓
返回 priceInfo { finalPrice, tp2, extraShare }
    ↓
executeHedgeFromOrderbook 使用 finalPrice
    ↓
executeHedgeTask 处理 extraShare 和 tp2
    ↓
提交任务时添加 tp2 字段
```

## 六、代码位置索引

- **设置字段定义**: 2824-2830行
- **UI设置输入框**: 300-367行
- **parseOrderbookData函数**: 7934-8295行
  - 深度差计算: 8122-8125行
  - 价格计算逻辑: 8159-8273行
- **executeHedgeFromOrderbook函数**: 8429-8570行
- **executeHedgeTask函数**: 10400行开始
  - extraShare处理: 10425-10430行
  - tp2添加: 10504-10508行
- **executeHedgeTaskV2函数**: 10968行开始
  - tp2添加: 11064行、11240行

